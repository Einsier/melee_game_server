### 说明
游戏基础玩法的游戏逻辑+游戏房间布置


玩法包括:
* 根据2D移动+近战攻击
* 拾取地图上的增益道具
* 拾取到子弹包后可以发射子弹,攻击其他玩家
* 玩家血量管理

游戏运行逻辑:

玩家从匹配服务器处进行排队((mvp1+待完善))

匹配服务器凑齐足够的人数,通知game_server开启一个game_room,将所有的playerId发给game_server(mvp1+待完善)

game_server使用一个端口开启一个game_room,game_room开始监听该端口并获取kcp包,初始等待全部玩家进入状态,并且把game_room的id返回给匹配服务器(mvp1+待完善)

匹配服务器将game_server和game_room的编号发给玩家(mvp1+待完善)

玩家使用从匹配服务器处得到game_room编号,加入对应的game_room(mvp1版本同一时刻仅有一个game_room)

game_room在玩家加入(玩家发送PlayerEnterGameRequest)时给玩家分配heroId,记录玩家的联系方式到NetServer中

game_room等待全部(configs.MaxNormalGamePlayerNum个)玩家进入,并且校验身份后开始游戏,具体操作是发送一个GameStartBroadcast给所有玩家

前端和后端进行四种格式的kcp通信,在game_room这一层里面实现对局和网络的解耦,即 game_room同时记录所有玩家的联系方式到NetServer中,用于通信,
并且内部存有若干个游戏有关的对象,以对当前的游戏地图,玩家,道具等进行管理.在game_room这一层 使用事件驱动(从被分配的game_room端口监听kcp)模型,
当有kcp报文来时译码,并根据报文的内容选择相应的消息处理函数进行处理.

![image-20220126021527975](C:\Users\Administrator\Desktop\melee_game_server\internal\normal_game\image-20220126021527975.png)

2022/1/22

* mvp1道具拾取逻辑:

  * 玩家a拾取子弹带:

    1.发送子弹带的道具id给后端,交给后端判定

    2.后端简单的看该子弹带存不存在,如果存在则删除该道具,并且向玩家a返回true

    3.玩家a收到拾取成功的resp后,前端加上发射子弹功能

  * 玩家a拾取草莓:

    1.发送草莓的道具id交给后端判定

    2.后端不做给玩家a单独应答,而是判断草莓存不存在,如果存在则删除该道具,并且向全体玩家广播道具删除事件以及玩家a加血事件

* mvp1子弹逻辑:

  * 玩家a发射子弹:

    1.捡到子弹带的玩家a发射子弹,玩家a的前端判断发射合法后显示发射动画

    2.玩家a将自己的int32类型的heroId和int32类型的用于表示本英雄本局发射的第几个子弹Id,合起来,生成一个id为int64类型的全局子弹id,把子弹维护到本地map中,key为int64的子弹id,value为子弹GameObject,并为自己的发射的子弹设置子弹和其他玩家碰撞的监听事件

    3.玩家a生成并发送HeroBulletLaunchRequest,其中包括int64类型的全局子弹id,子弹发射位置,发射方向给服务器

    4.服务器将int64类型的全局游戏的子弹id作为key,收到请求后生成的一个子弹实体指针,存入服务器的子弹管理map中.

    5.服务器向全部玩家广播这个子弹发射事件,发送一个int64类型的全局id以及子弹生成的位置,方向,时间,广播会发给除了玩家a之外的其他的玩家

    6.其他玩家收到广播后,生成一个子弹实体,进行前端展示,并使用int64的子弹id为key将这个子弹存到前端map中.

  * 玩家a子弹打击到另外的英雄:

    1.玩家a的前端监听到自己发射的子弹和其他英雄发生了碰撞(每个玩家只会监听自己发射的子弹的和其他英雄的碰撞情况)

    2.玩家a的前端暂时不渲染子弹消失特效,而是生成并发送一个HeroBulletColliderHeroRequest,其中包括被碰撞的heroId,自己的int64的子弹id,碰撞时间.后端结合子弹位置和被撞击的英雄的位置进行校验,如果碰撞有效,则给玩家a单播一个碰撞有效,给其它玩家广播一个子弹消失+英雄掉血广播.如果无效,不发送任何消息.

    3.全部玩家收到子弹消失广播,直接将广播中带的int64的子弹id为key从前端子弹map中取出子弹并删除.子弹在玩家视野里消失.

* mvp1玩家同步逻辑:
  * 玩家a按下方向键或者松开方向键(或者长时间没有按键变换),unity检测到,记录客户端当前时间以及玩家按键,发送ChangeMovementTypeRequest(或者ReportHeroPositionRequest)给服务器
  * 服务器将信息原封不动的转发给客户端,客户端通过这两个参数每一帧更新玩家a的位置信息.


2022/2/17
大修改...原本设想的是一个game_server使用的是一个ip地址,每一局运行在game_server中的游戏是使用这个ip地址上的一个端口.但是
经过老师指点,可能client为了保证通讯速度,是同game_room进行直连,如果一个game_room占用一个端口,可能会出现例如端口地址不够用,
同一时刻运行的最大单局有限的问题.
所以将每个game_server运行在一个端口上,然后在应用层根据每个game_room的id进行分发,分发给每个game_room的处理函数